using System;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;

class Injector
{
    [DllImport("kernel32.dll", SetLastError = true)]
    static extern IntPtr OpenProcess(int dwDesiredAccess, bool bInheritHandle, int dwProcessId);

    [DllImport("kernel32.dll", SetLastError = true)]
    static extern IntPtr VirtualAllocEx(IntPtr hProcess, IntPtr lpAddress, uint dwSize, uint flAllocationType, uint flProtect);

    [DllImport("kernel32.dll", SetLastError = true)]
    static extern bool WriteProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, byte[] lpBuffer, uint nSize, out IntPtr lpNumberOfBytesWritten);

    [DllImport("kernel32.dll")]
    static extern IntPtr GetProcAddress(IntPtr hModule, string procName);

    [DllImport("kernel32.dll")]
    static extern IntPtr GetModuleHandle(string lpModuleName);

    [DllImport("kernel32.dll", SetLastError = true)]
    static extern IntPtr CreateRemoteThread(IntPtr hProcess, IntPtr lpThreadAttributes,
        uint dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, IntPtr lpThreadId);

    [DllImport("kernel32.dll")]
    static extern IntPtr OpenThread(ThreadAccess dwDesiredAccess, bool bInheritHandle, uint dwThreadId);

    [DllImport("ntdll.dll")]
    private static extern int NtQueryInformationThread(IntPtr ThreadHandle, int ThreadInformationClass,
        out IntPtr ThreadInformation, int ThreadInformationLength, IntPtr ReturnLength);

    [DllImport("kernel32.dll")]
    static extern uint SuspendThread(IntPtr hThread);

    [Flags]
    public enum ThreadAccess : int
    {
        SUSPEND_RESUME = 0x0002,
        QUERY_INFORMATION = 0x0040
    }

    static void Main()
    {
        string dllPath = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "cat.dll");
        if (!File.Exists(dllPath))
        {
            Console.WriteLine("cat.dll not found in current directory.");
            return;
        }

        Process target = Process.GetProcessesByName("RobloxPlayerBeta").FirstOrDefault();
        if (target == null)
        {
            Console.WriteLine("RobloxPlayerBeta.exe not found.");
            return;
        }

        try
        {
            Console.WriteLine($"Target PID: {target.Id}");
            InjectDll(target.Id, dllPath);
            Console.WriteLine("DLL injected successfully.");
        }
        catch (Exception ex)
        {
            Console.WriteLine("Injection failed: " + ex.Message);
        }
    }

    static void InjectDll(int pid, string dllPath)
    {
        const int PROCESS_ALL_ACCESS = 0x1F0FFF;
        const uint MEM_COMMIT = 0x1000;
        const uint PAGE_READWRITE = 0x04;

        IntPtr hProcess = OpenProcess(PROCESS_ALL_ACCESS, false, pid);
        if (hProcess == IntPtr.Zero)
            throw new Exception("Cannot open process");

        byte[] dllBytes = System.Text.Encoding.ASCII.GetBytes(dllPath + "\0");
        IntPtr allocAddress = VirtualAllocEx(hProcess, IntPtr.Zero, (uint)dllBytes.Length, MEM_COMMIT, PAGE_READWRITE);
        if (allocAddress == IntPtr.Zero)
            throw new Exception("Memory allocation failed");

        WriteProcessMemory(hProcess, allocAddress, dllBytes, (uint)dllBytes.Length, out _);

        SuspendThreadsInNtdll(pid);

        IntPtr loadLibraryAddr = GetProcAddress(GetModuleHandle("kernel32.dll"), "LoadLibraryA");
        if (loadLibraryAddr == IntPtr.Zero)
            throw new Exception("LoadLibraryA address not found");

        IntPtr remoteThread = CreateRemoteThread(hProcess, IntPtr.Zero, 0, loadLibraryAddr, allocAddress, 0, IntPtr.Zero);
        if (remoteThread == IntPtr.Zero)
            throw new Exception("CreateRemoteThread failed");
    }

    static void SuspendThreadsInNtdll(int pid)
    {
        var process = Process.GetProcessById(pid);

        foreach (ProcessThread thread in process.Threads)
        {
            try
            {
                IntPtr hThread = OpenThread(ThreadAccess.SUSPEND_RESUME | ThreadAccess.QUERY_INFORMATION, false, (uint)thread.Id);
                if (hThread == IntPtr.Zero) continue;

                NtQueryInformationThread(hThread, 9, out var startAddress, IntPtr.Size, IntPtr.Zero);
                if (IsAddressInNtdll(pid, startAddress))
                {
                    SuspendThread(hThread);
                }
            }
            catch { }
        }
    }

    static bool IsAddressInNtdll(int pid, IntPtr address)
    {
        var process = Process.GetProcessById(pid);
        foreach (ProcessModule module in process.Modules)
        {
            if (module.ModuleName.ToLower().Contains("ntdll"))
            {
                IntPtr baseAddr = module.BaseAddress;
                IntPtr endAddr = (IntPtr)((long)baseAddr + module.ModuleMemorySize);

                if ((ulong)address.ToInt64() >= (ulong)baseAddr.ToInt64() &&
                    (ulong)address.ToInt64() <= (ulong)endAddr.ToInt64())
                    return true;
            }
        }
        return false;
    }
}
